---
title: Chapter 2 - Housekeeping
description: Boring stuff time! Setting up your config to be easier to edit and maintain later
---

import { FileTree, Aside, Steps } from '@astrojs/starlight/components';

So far we've been working in one file with no VCS setup and no consistent formatting.

In this chapter we will...

1. Get a Git repo set up for our system
2. Learn how to compartmentalize our config into different files
3. Do some setup for next chapter in `flake.nix`
4. Setup auto-formatting for our code

## Setting Up Git

Before we do anything, we'll need to make a `.gitignore`, I'd recommend the following:

<Steps>
1. Create a `.gitignore` file to prevent unwanted files from being checked in
    <FileTree>
    - flake.nix
    - **.gitignore** Make sure it's in the root!
    - ...
    </FileTree>

    ```txt title=".gitignore"
    # Symlink to anything nix built (no trailing slash)
    result 
    # The VM image file QEMU creates for our VM
    nixos.qcow2
    ```
2. Now initialize a new Git repo for your project.
    ```sh
    git init
    git add .
    git commit -m "Initial Commit"
    ```
</Steps>

We now have a git repo for our config!

<Aside title="From Now On..." type="caution">
Whenever we *create or rename* a file in our repo, we need to add it in git for Nix to see it. 
```sh
git add .
```
If you ever get an error saying a file in the config could not be found, this is likely the cause.
</Aside>

## Fragmenting Our Config

Now we need to split up our NixOS config from one file, this is for our own good and we'll actually use it later.

First, create files for each part of our config.

To keep things clean, you probably want to put these in a folder called `modules`. **flake.nix should not go in this folder, flake files must be in the root of the repo.**

Anything highlighted is something this guide is going to use later, so they'll be required. Anything not highlighted is a suggestion based on how others tend to separate files, but pick what works best for you!

<FileTree>
- flake.nix
- flake.lock
- modules/
  - **config.nix** Sets up basics and imports all other modules
  - **nix.nix** Configures Nix itself within the VM
  - graphics.nix (DEs, apps, theming, etc)
  - shell.nix (Aliases, themes, etc)
  - ... Go wild!
</FileTree>

Now you'll need to edit the path specified in `flake.nix` in the `modules` array to point to `./modules/config.nix` instead.

<Aside type="tip" title="Pop Quiz!">We just made files! What do we do to make sure Nix can see them?</Aside>

### Importing other modules from config.nix

Now we need to tell NixOS what other files to look at for modules.
To do this, in `config.nix` create a new array called `imports` (usually this is the very first config option).
This array should have the paths (relative to `config.nix`) of other modules to load.

```nix title="modules/config.nix" ins={2}
{pkgs, ...}: {
  imports = [./nix.nix ./graphics.nix ./shell.nix];

  # ...
}
```

### File Contents

Now the files we created need to actually be filled, use config.nix as reference, remember each module must return
an attr set and are given a bunch of arguments. A good template for a module is:

```nix title="modules/some-module.nix"
{pkgs, ...}: {

}
```

From there feel free to build your source tree however you want!

<Aside type="tip">
Remember that Nix/NixOS merges a lot of stuff! For example you can define `environment.systemPackages` in multiple files and it will aggregate all the items into one big array.

If two things in different modules collide Nix will fail to evaluate and let you know.
</Aside>

### Making nix.nix

I'll leave exactly where to place certain options up to you, however this guide is going to require you to place
the `nix = { ... }` option inside `modules/nix.nix`, we'll be importing it from somewhere else later.

<Steps>
1. Remove the `nix` attr set from `modules/config.nix`...
    ```nix title="modules/config.nix" del={3-17}
    {pkgs, ...}: {
      # ...
      nix = {
        channel.enable = false;
        package = pkgs.lix;
        settings = {
          experimental-features = [
            "nix-command"
            "flakes"
          ];
          auto-optimise-store = true;
        };
        gc = {
          automatic = true;
          dates = "weekly";
        };
      };
      # ...
    }
    ```

2. Then add it in `modules/nix.nix`...
    ```nix title="modules/nix.nix" ins={2-16}
    {pkgs, ...}: {
      nix = {
        channel.enable = false;
        package = pkgs.lix;
        settings = {
          experimental-features = [
            "nix-command"
            "flakes"
          ];
          auto-optimise-store = true;
        };
        gc = {
          automatic = true;
          dates = "weekly";
        };
      };
    }
    ```
</Steps>

### Try Building

Before continuing, make sure your config still builds and your VM is how you want it.

## Passing inputs to our configuration

So when I said there were only two methods to install software I kinda lied...

Nix flakes are a wonderful way to get software straight from the repo the software is hosted on. We can
see in our `flake.nix` we're grabbing `nixpkgs` from github, and since NixOS expects nix packages we have it already
within our NixOS configuration.

However, there may come a time that we need to access other inputs within our configuration. In order to do this we need to tell NixOS additional arguments to pass.

<Steps>
1. On the line with `outputs = {`, put `inputs @` right before the `{`.
    ```nix title="flake.nix" ins="inputs @ "
    outputs = inputs @ {
        self,
        nixpkgs
    }: let
    ```
    This makes a new variable called `inputs` available that contains all of our flake inputs.
2. Create a new attr set in our call to `pkgs.lib.nixosSystem` called `specialArgs`, we'll want to `inherit inputs;` here.
    ```nix title="flake.nix" ins={3} "YOURNAME"
    nixosConfigurations.YOURNAME = pkgs.lib.nixosSystem {
      # ...
      specialArgs = { inherit inputs; };
      modules = [
        # ...
      ];
    }
    ```
3. Now when we need to, we can specify `inputs` in our arguments on any module and have access to our flake inputs.
    ```nix title="modules/some-module.nix" ins="inputs, "
    {inputs, pkgs, ...}: {
      # Access to flake inputs!
    }
    ```
</Steps>

Our only inputs at the moment are `self` and `nixpkgs`, but as we add more this will come in handy.

## Auto-formatting

This step is optional but I'd recommend it if you're like me and enjoy consistent style in your code.
Another type of output a nix flake can provide is a `formatter`. This should be set to a package that has the ability to
format Nix code, I'll use `alejandra` in this example.

To setup a formatter simply add to the outputs attr set:

```nix title="flake.nix" ins={5}
outputs = inputs @ {
  self,
  nixpkgs
}: ... {
  formatter.${system} = pkgs.alejandra;

  # ...
}
```

Now we can format our code with Alejandra.

```sh
nix fmt
```

<Aside type="tip">
There's also a VSCode extension, `kamadorueda.alejandra`, that can allow VSCode to run formatting for you. This is also handy as a syntax checker as it won't format if you have invalid syntax.
</Aside>
